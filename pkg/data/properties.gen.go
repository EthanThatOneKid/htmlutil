// Code generated by schema-generate. DO NOT EDIT.

package data

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// Property
type Property map[string]*Anonymous1

// Anonymous1 
type Anonymous1 struct {
  AlsoAppliesTo []interface{} `json:"alsoAppliesTo,omitempty"`
  AnimationType interface{} `json:"animationType"`
  Appliesto interface{} `json:"appliesto"`
  Computed interface{} `json:"computed"`
  Groups []interface{} `json:"groups"`
  Inherited bool `json:"inherited"`
  Initial interface{} `json:"initial"`
  MdnUrl string `json:"mdn_url,omitempty"`
  Media interface{} `json:"media"`
  Order interface{} `json:"order"`
  Percentages interface{} `json:"percentages"`
  Stacking bool `json:"stacking,omitempty"`
  Status interface{} `json:"status"`
  Syntax string `json:"syntax"`
}

func (strct *Anonymous1) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "alsoAppliesTo" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"alsoAppliesTo\": ")
	if tmp, err := json.Marshal(strct.AlsoAppliesTo); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "AnimationType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "animationType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"animationType\": ")
	if tmp, err := json.Marshal(strct.AnimationType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Appliesto" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "appliesto" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"appliesto\": ")
	if tmp, err := json.Marshal(strct.Appliesto); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Computed" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "computed" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"computed\": ")
	if tmp, err := json.Marshal(strct.Computed); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Groups" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "groups" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"groups\": ")
	if tmp, err := json.Marshal(strct.Groups); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Inherited" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "inherited" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"inherited\": ")
	if tmp, err := json.Marshal(strct.Inherited); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Initial" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "initial" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"initial\": ")
	if tmp, err := json.Marshal(strct.Initial); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "mdn_url" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"mdn_url\": ")
	if tmp, err := json.Marshal(strct.MdnUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Media" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "media" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"media\": ")
	if tmp, err := json.Marshal(strct.Media); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Order" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "order" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"order\": ")
	if tmp, err := json.Marshal(strct.Order); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Percentages" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "percentages" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"percentages\": ")
	if tmp, err := json.Marshal(strct.Percentages); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "stacking" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"stacking\": ")
	if tmp, err := json.Marshal(strct.Stacking); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Status" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "status" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Syntax" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "syntax" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"syntax\": ")
	if tmp, err := json.Marshal(strct.Syntax); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Anonymous1) UnmarshalJSON(b []byte) error {
    animationTypeReceived := false
    appliestoReceived := false
    computedReceived := false
    groupsReceived := false
    inheritedReceived := false
    initialReceived := false
    mediaReceived := false
    orderReceived := false
    percentagesReceived := false
    statusReceived := false
    syntaxReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "alsoAppliesTo":
            if err := json.Unmarshal([]byte(v), &strct.AlsoAppliesTo); err != nil {
                return err
             }
        case "animationType":
            if err := json.Unmarshal([]byte(v), &strct.AnimationType); err != nil {
                return err
             }
            animationTypeReceived = true
        case "appliesto":
            if err := json.Unmarshal([]byte(v), &strct.Appliesto); err != nil {
                return err
             }
            appliestoReceived = true
        case "computed":
            if err := json.Unmarshal([]byte(v), &strct.Computed); err != nil {
                return err
             }
            computedReceived = true
        case "groups":
            if err := json.Unmarshal([]byte(v), &strct.Groups); err != nil {
                return err
             }
            groupsReceived = true
        case "inherited":
            if err := json.Unmarshal([]byte(v), &strct.Inherited); err != nil {
                return err
             }
            inheritedReceived = true
        case "initial":
            if err := json.Unmarshal([]byte(v), &strct.Initial); err != nil {
                return err
             }
            initialReceived = true
        case "mdn_url":
            if err := json.Unmarshal([]byte(v), &strct.MdnUrl); err != nil {
                return err
             }
        case "media":
            if err := json.Unmarshal([]byte(v), &strct.Media); err != nil {
                return err
             }
            mediaReceived = true
        case "order":
            if err := json.Unmarshal([]byte(v), &strct.Order); err != nil {
                return err
             }
            orderReceived = true
        case "percentages":
            if err := json.Unmarshal([]byte(v), &strct.Percentages); err != nil {
                return err
             }
            percentagesReceived = true
        case "stacking":
            if err := json.Unmarshal([]byte(v), &strct.Stacking); err != nil {
                return err
             }
        case "status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
            statusReceived = true
        case "syntax":
            if err := json.Unmarshal([]byte(v), &strct.Syntax); err != nil {
                return err
             }
            syntaxReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if animationType (a required property) was received
    if !animationTypeReceived {
        return errors.New("\"animationType\" is required but was not present")
    }
    // check if appliesto (a required property) was received
    if !appliestoReceived {
        return errors.New("\"appliesto\" is required but was not present")
    }
    // check if computed (a required property) was received
    if !computedReceived {
        return errors.New("\"computed\" is required but was not present")
    }
    // check if groups (a required property) was received
    if !groupsReceived {
        return errors.New("\"groups\" is required but was not present")
    }
    // check if inherited (a required property) was received
    if !inheritedReceived {
        return errors.New("\"inherited\" is required but was not present")
    }
    // check if initial (a required property) was received
    if !initialReceived {
        return errors.New("\"initial\" is required but was not present")
    }
    // check if media (a required property) was received
    if !mediaReceived {
        return errors.New("\"media\" is required but was not present")
    }
    // check if order (a required property) was received
    if !orderReceived {
        return errors.New("\"order\" is required but was not present")
    }
    // check if percentages (a required property) was received
    if !percentagesReceived {
        return errors.New("\"percentages\" is required but was not present")
    }
    // check if status (a required property) was received
    if !statusReceived {
        return errors.New("\"status\" is required but was not present")
    }
    // check if syntax (a required property) was received
    if !syntaxReceived {
        return errors.New("\"syntax\" is required but was not present")
    }
    return nil
}
